{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Assignment 2 - Solutions\"\n",
        "bibliography: ../reading_list.bib\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "    toc-depth: 2\n",
        "    toc-location: left\n",
        "    theme: default\n",
        "    code-fold: false\n",
        "    code-tools: true\n",
        "    embed-resources: true\n",
        "    self-contained: true\n",
        "---"
      ],
      "id": "cb1f0b0e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "using LinearAlgebra, Plots, Distributions"
      ],
      "id": "b5421a03",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Question 1\n",
        "\n",
        "Using the same model outlined in [recitation 2](../recitations/recitation-2.qmd) and [recitation 3](../recitations/recitation-3.qmd), solve two versions of the model with $\\rho = 0.95$ and $\\rho=0.1$, keeping all other parameters the same as in those recitations.\n",
        "\n",
        "## Solution\n",
        "\n",
        "First, let's set up all the functions we need from the recitations:\n"
      ],
      "id": "f120fea3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Utility function\n",
        "utility(c,σ) = c^(1 - σ) / (1 - σ)\n",
        "\n",
        "# Tauchen method for discretizing AR(1) process\n",
        "function tauchen(N, ρ, σ)\n",
        "    # Unconditional standard deviation of the process\n",
        "    σ_y = σ / sqrt(1 - ρ^2)\n",
        "\n",
        "    # Create the grid\n",
        "    y_max = 3. * σ_y\n",
        "    y_min = - 3. * σ_y\n",
        "    grid = range(y_min, y_max, length=N)\n",
        "\n",
        "    # Step size\n",
        "    step = (y_max - y_min) / (N - 1)\n",
        "\n",
        "    # Initialize transition matrix\n",
        "    Π = zeros(N, N)\n",
        "\n",
        "    # Standard normal distribution\n",
        "    d = Normal(0, 1)\n",
        "\n",
        "    # Fill in the transition matrix\n",
        "    for i in 1:N\n",
        "        for j in 1:N\n",
        "            if j == 1\n",
        "                # Probability of transitioning to the lowest state\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ)\n",
        "            elseif j == N\n",
        "                # Probability of transitioning to the highest state\n",
        "                Π[j, i] = 1 - cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            else\n",
        "                # Probability of transitioning to intermediate states\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ) -\n",
        "                         cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return collect(grid), Π\n",
        "end\n",
        "\n",
        "# Solve value function at a point\n",
        "function solve_value(ai,yi,V,p,t)\n",
        "    (;σ,β,Π,r,asset_grid,income_grid,net_income) = p\n",
        "    a = asset_grid[ai]\n",
        "    y = exp(income_grid[yi,t])\n",
        "    y_net = net_income(y)\n",
        "    vmax = -Inf\n",
        "    amax = 0\n",
        "    for ai_next in eachindex(asset_grid)\n",
        "        a_next = asset_grid[ai_next]\n",
        "        c = y_net + a - a_next/(1+r)\n",
        "        if c>0\n",
        "            @views v = utility(c,σ) + β*dot(Π[:,yi],V[:,ai_next,t+1])\n",
        "            if v>vmax\n",
        "                vmax = v\n",
        "                amax = a_next\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return vmax,amax\n",
        "end\n",
        "\n",
        "# Iterate value function\n",
        "function iterate_value_function!(p,V,A,t)\n",
        "    for ai in axes(V,2), yi in axes(V,1)\n",
        "        v,a_next = solve_value(ai,yi,V,p,t)\n",
        "        V[yi,ai,t] = v\n",
        "        A[yi,ai,t] = a_next\n",
        "    end\n",
        "end\n",
        "\n",
        "# Solve the model\n",
        "function solve_model(p)\n",
        "    (;T,Π,asset_grid) = p\n",
        "    K_a = length(asset_grid)\n",
        "    K_y = size(Π,1)\n",
        "    V = zeros(K_y,K_a,T+1)\n",
        "    A = zeros(K_y,K_a,T)\n",
        "    for t in reverse(1:T)\n",
        "        iterate_value_function!(p,V,A,t)\n",
        "    end\n",
        "    return (;V,A)\n",
        "end\n",
        "\n",
        "# No tax function\n",
        "no_tax(x) = x"
      ],
      "id": "a4da0240",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now solve for $\\rho = 0.95$:\n"
      ],
      "id": "a5cbb82f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "μ = log(10.)\n",
        "T = 60\n",
        "\n",
        "# Model with ρ = 0.95\n",
        "egrid_95, Π_95 = tauchen(5, 0.95, 0.1)\n",
        "income_grid_95 = [μ + egrid_95[i] for i in 1:5, t in 1:T]\n",
        "\n",
        "p_95 = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0, 100, 100),\n",
        "    income_grid = income_grid_95,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π = Π_95,\n",
        "    σ = 2.,\n",
        "    net_income = no_tax\n",
        ")\n",
        "\n",
        "model_95 = solve_model(p_95)"
      ],
      "id": "c7e54e5e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now solve for $\\rho = 0.1$:\n"
      ],
      "id": "027b07a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Model with ρ = 0.1\n",
        "egrid_10, Π_10 = tauchen(5, 0.1, 0.1)\n",
        "income_grid_10 = [μ + egrid_10[i] for i in 1:5, t in 1:T]\n",
        "\n",
        "p_10 = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0, 100, 100),\n",
        "    income_grid = income_grid_10,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π = Π_10,\n",
        "    σ = 2.,\n",
        "    net_income = no_tax\n",
        ")\n",
        "\n",
        "model_10 = solve_model(p_10)"
      ],
      "id": "cf82f912",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's compare the value functions:\n"
      ],
      "id": "d800f7f8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plot(model_95.V[:,1,1], label = \"ρ = 0.95\",\n",
        "     xlabel = \"Income state\", ylabel = \"Value\",\n",
        "     title = \"Value Function Comparison (a=0, t=1)\")\n",
        "plot!(model_10.V[:,1,1], label = \"ρ = 0.1\")"
      ],
      "id": "ceb8ecae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With lower persistence ($\\rho = 0.1$), the value function is higher across all income states because shocks are less persistent.\n",
        "\n",
        "# Question 2\n",
        "\n",
        "Given agents live for $T$ periods, note that for a guaranteed consumption level $\\bar{c}$, we have:\n",
        "$$ \\mathcal{V}(\\bar{c}) = \\sum_{t=0}^{T}\\beta^{t}u(\\bar{c}) = \\frac{1-\\beta^{T}}{1-\\beta}u(\\bar{c}).$$\n",
        "\n",
        "Given this, show that:\n",
        "$$ \\bar{c}(y) = \\left[(1-\\sigma)\\frac{1-\\beta}{1-\\beta^{T}}V(0,y)\\right]^{1/(1-\\sigma)} $$\n",
        "is the consumption equivalent that, if delivered with certainty in every period, would achieve the same value as $V(0,y)$.\n",
        "\n",
        "## Solution\n",
        "\n",
        "By definition, the consumption equivalent $\\bar{c}(y)$ satisfies:\n",
        "$$ \\mathcal{V}(\\bar{c}(y)) = V(0,y) $$\n",
        "\n",
        "Substituting the formula for $\\mathcal{V}$:\n",
        "$$ \\frac{1-\\beta^{T}}{1-\\beta}u(\\bar{c}(y)) = V(0,y) $$\n",
        "\n",
        "For CRRA utility, $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$, so:\n",
        "$$ \\frac{1-\\beta^{T}}{1-\\beta} \\cdot \\frac{\\bar{c}(y)^{1-\\sigma}}{1-\\sigma} = V(0,y) $$\n",
        "\n",
        "Solving for $\\bar{c}(y)$:\n",
        "$$ \\bar{c}(y)^{1-\\sigma} = V(0,y) \\cdot \\frac{(1-\\sigma)(1-\\beta)}{1-\\beta^{T}} $$\n",
        "\n",
        "Taking the $\\frac{1}{1-\\sigma}$ power of both sides:\n",
        "$$ \\bar{c}(y) = \\left[(1-\\sigma)\\frac{1-\\beta}{1-\\beta^{T}}V(0,y)\\right]^{1/(1-\\sigma)} $$\n",
        "\n",
        "# Question 3\n",
        "\n",
        "Assume that the government now levies a 10% proportional income tax that it then redistributes as a lump sum. Thus, net income for an agent is\n",
        "$$ \\tilde{y} = 0.9 \\times y + 0.1\\times\\mathbb{E}[y] $$\n",
        "where $\\mathbb{E}[y] = \\sum_{y}\\pi^*(y)y$ and $\\pi^*$ is the stationary distribution of the transition matrix $\\Pi$. Write code to solve the model with this system of taxes and transfers. Show that this net income function respects the aggregate resource constraint.\n",
        "\n",
        "## Solution\n",
        "\n",
        "First, we need helper functions to find the stationary distribution and construct the tax system:\n"
      ],
      "id": "04413250"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Find stationary distribution\n",
        "function solve_steady_state(Π)\n",
        "    K = size(Π, 2)\n",
        "    vals, e = eigen(Π)\n",
        "    return e[:, K] ./ sum(e[:, K])\n",
        "end\n",
        "\n",
        "# Construct proportional tax with lump-sum transfer\n",
        "function proportional_tax_transfer(y, mean_y, τ)\n",
        "    return (1 - τ) * y + τ * mean_y\n",
        "end"
      ],
      "id": "987ddf17",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now solve the model with 10% proportional tax for $\\rho = 0.95$:\n"
      ],
      "id": "08fd015f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Calculate stationary distribution and mean income\n",
        "pi_star_95 = solve_steady_state(Π_95)\n",
        "mean_y_95 = dot(pi_star_95, exp.(income_grid_95[:, 1]))\n",
        "\n",
        "# Tax rate\n",
        "τ = 0.1\n",
        "\n",
        "# Create net income function\n",
        "net_income_tax = y -> proportional_tax_transfer(y, mean_y_95, τ)\n",
        "\n",
        "# Solve model with taxes\n",
        "p_95_tax = (;p_95..., net_income = net_income_tax)\n",
        "model_95_tax = solve_model(p_95_tax)"
      ],
      "id": "2d68af89",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Showing the resource constraint is respected:**\n",
        "\n",
        "The aggregate resource constraint requires that average net income equals average gross income. The resource constraint holds because:\n",
        "$$\\mathbb{E}[\\tilde{y}] = \\mathbb{E}[0.9y + 0.1\\mathbb{E}[y]] = 0.9\\mathbb{E}[y] + 0.1\\mathbb{E}[y] = \\mathbb{E}[y]$$\n",
        "\n",
        "Now solve for $\\rho = 0.1$ with taxes:\n"
      ],
      "id": "1ec56b23"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Calculate stationary distribution and mean income for ρ = 0.1\n",
        "pi_star_10 = solve_steady_state(Π_10)\n",
        "mean_y_10 = dot(pi_star_10, exp.(income_grid_10[:, 1]))\n",
        "\n",
        "# Create net income function\n",
        "net_income_tax_10 = y -> proportional_tax_transfer(y, mean_y_10, τ)\n",
        "\n",
        "# Solve model with taxes\n",
        "p_10_tax = (;p_10..., net_income = net_income_tax_10)\n",
        "model_10_tax = solve_model(p_10_tax)"
      ],
      "id": "6aa9c8ff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Question 4\n",
        "\n",
        "Define\n",
        "$$W^{r} = \\sum_{y}\\pi^*(y)V^{r}(0,y) = \\mathbb{E}[V^{r}(0,y)]$$\n",
        "to be utilitarian welfare under regime $r\\in\\{A,B\\}$ where regime $A$ is the laissez-faire economy and regime $B$ is the economy with taxes and transfers. For both models, calculate the decomposition of the consumption equivalent measure of welfare gains.\n",
        "\n",
        "## Solution\n",
        "\n",
        "We'll calculate the welfare decomposition for both $\\rho = 0.95$ and $\\rho = 0.1$.\n",
        "\n",
        "### For $\\rho = 0.95$:\n"
      ],
      "id": "0c0948ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "(;σ, β) = p_95\n",
        "\n",
        "# Aggregate consumption (same in both regimes)\n",
        "C_95 = dot(pi_star_95, exp.(income_grid_95[:, 1]))\n",
        "\n",
        "# Certainty equivalent function\n",
        "V_cert(x) = (1 - β^T) / (1 - β) * utility(x, σ)\n",
        "\n",
        "# Consumption equivalents for regime A (no tax)\n",
        "cbar_95_A = ((1 - σ) * (1 - β) / (1 - β^T) * model_95.V[:, 1, 1]) .^ (1 / (1 - σ))\n",
        "\n",
        "# Consumption equivalents for regime B (with tax)\n",
        "cbar_95_B = ((1 - σ) * (1 - β) / (1 - β^T) * model_95_tax.V[:, 1, 1]) .^ (1 / (1 - σ))\n",
        "\n",
        "# Average consumption equivalents\n",
        "Cbar_95_A = dot(pi_star_95, cbar_95_A)\n",
        "Cbar_95_B = dot(pi_star_95, cbar_95_B)\n",
        "\n",
        "# Utilitarian welfare\n",
        "W_95_A = dot(pi_star_95, model_95.V[:, 1, 1])\n",
        "W_95_B = dot(pi_star_95, model_95_tax.V[:, 1, 1])\n",
        "\n",
        "# Welfare decomposition\n",
        "ω_95 = (W_95_B / W_95_A)^(1 / (1 - σ)) - 1  # Total gain\n",
        "γ_95 = (V_cert(Cbar_95_B) / V_cert(Cbar_95_A))^(1 / (1 - σ)) - 1  # Insurance gain\n",
        "α_95 = ((W_95_B / V_cert(Cbar_95_B)) / (W_95_A / V_cert(Cbar_95_A)))^(1 / (1 - σ)) - 1  # Redistribution gain\n",
        "\n",
        "println(\"ρ = 0.95 Welfare Decomposition:\")\n",
        "println(\"Total gain (1+ω): \", 1 + ω_95)\n",
        "println(\"Insurance gain (1+γ): \", 1 + γ_95)\n",
        "println(\"Redistribution gain (1+α): \", 1 + α_95)\n",
        "println(\"Verification (1+ω) ≈ (1+γ)(1+α): \", (1 + γ_95) * (1 + α_95))"
      ],
      "id": "66076d9c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### For $\\rho = 0.1$:\n"
      ],
      "id": "70528153"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Aggregate consumption (same in both regimes)\n",
        "C_10 = dot(pi_star_10, exp.(income_grid_10[:, 1]))\n",
        "\n",
        "# Consumption equivalents for regime A (no tax)\n",
        "cbar_10_A = ((1 - σ) * (1 - β) / (1 - β^T) * model_10.V[:, 1, 1]) .^ (1 / (1 - σ))\n",
        "\n",
        "# Consumption equivalents for regime B (with tax)\n",
        "cbar_10_B = ((1 - σ) * (1 - β) / (1 - β^T) * model_10_tax.V[:, 1, 1]) .^ (1 / (1 - σ))\n",
        "\n",
        "# Average consumption equivalents\n",
        "Cbar_10_A = dot(pi_star_10, cbar_10_A)\n",
        "Cbar_10_B = dot(pi_star_10, cbar_10_B)\n",
        "\n",
        "# Utilitarian welfare\n",
        "W_10_A = dot(pi_star_10, model_10.V[:, 1, 1])\n",
        "W_10_B = dot(pi_star_10, model_10_tax.V[:, 1, 1])\n",
        "\n",
        "# Welfare decomposition\n",
        "ω_10 = (W_10_B / W_10_A)^(1 / (1 - σ)) - 1  # Total gain\n",
        "γ_10 = (V_cert(Cbar_10_B) / V_cert(Cbar_10_A))^(1 / (1 - σ)) - 1  # Insurance gain\n",
        "α_10 = ((W_10_B / V_cert(Cbar_10_B)) / (W_10_A / V_cert(Cbar_10_A)))^(1 / (1 - σ)) - 1  # Redistribution gain\n",
        "\n",
        "println(\"ρ = 0.1 Welfare Decomposition:\")\n",
        "println(\"Total gain (1+ω): \", 1 + ω_10)\n",
        "println(\"Insurance gain (1+γ): \", 1 + γ_10)\n",
        "println(\"Redistribution gain (1+α): \", 1 + α_10)\n",
        "println(\"Verification (1+ω) ≈ (1+γ)(1+α): \", (1 + γ_10) * (1 + α_10))"
      ],
      "id": "a7ba07a2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Question 5\n",
        "\n",
        "Comment on the difference in this decomposition for $\\rho=0.95$ vs $\\rho=0.1$. Can you give some intuition for the difference?\n",
        "\n",
        "## Solution\n",
        "\n",
        "Let's create a comparison table:\n"
      ],
      "id": "b202e34e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Printf\n",
        "\n",
        "println(\"\\nComparison of Welfare Decompositions:\")\n",
        "println(\"=\"^60)\n",
        "println(@sprintf(\"%-20s %12s %12s\", \"Component\", \"ρ = 0.95\", \"ρ = 0.1\"))\n",
        "println(\"=\"^60)\n",
        "println(@sprintf(\"%-20s %12.4f %12.4f\", \"Total (1+ω)\", 1 + ω_95, 1 + ω_10))\n",
        "println(@sprintf(\"%-20s %12.4f %12.4f\", \"Insurance (1+γ)\", 1 + γ_95, 1 + γ_10))\n",
        "println(@sprintf(\"%-20s %12.4f %12.4f\", \"Redistribution (1+α)\", 1 + α_95, 1 + α_10))\n",
        "println(\"=\"^60)"
      ],
      "id": "fecc393d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Intuition:**\n",
        "\n",
        "- High persistence ($\\rho \\approx 1$) → income inequality is mostly *permanent* → welfare gains mostly redistribution\n",
        "- Low persistence ($\\rho \\approx 0$) → income inequality is mostly *transitory* → welfare gains mostly insurance\n",
        "- When persistence ($\\rho$) is lower, shocks are easier to insure against → lower overall welfare gains.\n"
      ],
      "id": "9e539191"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}