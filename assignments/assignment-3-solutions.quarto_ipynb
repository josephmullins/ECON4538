{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Assignment 3 - Solutions\"\n",
        "bibliography: ../reading_list.bib\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "    toc-depth: 2\n",
        "    toc-location: left\n",
        "    theme: default\n",
        "    code-fold: false\n",
        "    code-tools: true\n",
        "    embed-resources: true\n",
        "    self-contained: true\n",
        "---"
      ],
      "id": "8b7a135b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using DataFrames, DataFramesMeta, CSV, StatsPlots, LinearAlgebra, Distributions, StatsBase"
      ],
      "id": "7fd64cb8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Question 1: Deriving Variance and Covariance Relationships\n",
        "\n",
        "Given the income process:\n",
        "$$ y_{it} = \\mu_{t} + \\alpha_{i} + \\zeta_{it} + \\epsilon_{it} $$\n",
        "\n",
        "where $\\zeta_{it} = \\rho \\zeta_{it-1} + \\eta_{it}$, $\\alpha_{i} \\sim (0, \\sigma^2_{\\alpha})$, $\\epsilon_{it} \\sim N(0, \\sigma^2_{\\epsilon})$, and $\\eta_{it} \\sim N(0, \\sigma^2_{\\eta})$ are all independent.\n",
        "\n",
        "**Variance of $y_{it}$:**\n",
        "\n",
        "Since all components are independent:\n",
        "$$\n",
        "\\begin{align}\n",
        "\\mathbb{V}[y_{it}] &= \\mathbb{V}[\\mu_t + \\alpha_i + \\zeta_{it} + \\epsilon_{it}] \\\\\n",
        "&= \\mathbb{V}[\\alpha_i] + \\mathbb{V}[\\zeta_{it}] + \\mathbb{V}[\\epsilon_{it}] \\\\\n",
        "&= \\sigma^2_{\\alpha} + \\mathbb{V}[\\zeta_{it}] + \\sigma^2_{\\epsilon}\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "**Covariance of $y_{it}$ and $y_{it+s}$:**\n",
        "\n",
        "For the same individual $i$ at different times:\n",
        "$$\n",
        "\\begin{align}\n",
        "\\mathbb{C}(y_{it}, y_{it+s}) &= \\mathbb{C}(\\alpha_i + \\zeta_{it} + \\epsilon_{it}, \\alpha_i + \\zeta_{it+s} + \\epsilon_{it+s}) \\\\\n",
        "&= \\mathbb{C}(\\alpha_i, \\alpha_i) + \\mathbb{C}(\\zeta_{it}, \\zeta_{it+s}) + \\mathbb{C}(\\epsilon_{it}, \\epsilon_{it+s})\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "Since $\\alpha_i$ is permanent: $\\mathbb{C}(\\alpha_i, \\alpha_i) = \\mathbb{V}[\\alpha_i] = \\sigma^2_{\\alpha}$\n",
        "\n",
        "Since $\\epsilon_{it}$ is measurement error (iid): $\\mathbb{C}(\\epsilon_{it}, \\epsilon_{it+s}) = 0$ for $s > 0$\n",
        "\n",
        "For the AR(1) component: $\\mathbb{C}(\\zeta_{it}, \\zeta_{it+s}) = \\rho^s \\mathbb{V}[\\zeta_{it}]$\n",
        "\n",
        "Therefore:\n",
        "$$\n",
        "\\mathbb{C}(y_{it}, y_{it+s}) = \\sigma^2_{\\alpha} + \\rho^s \\mathbb{V}[\\zeta_{it}]\n",
        "$$\n",
        "\n",
        "# Question 2: Expressing Parameters in Terms of Moments\n",
        "\n",
        "From Question 1, we have:\n",
        "$$\n",
        "\\begin{align}\n",
        "\\mathbb{V}[y_{it}] &= \\sigma^2_{\\alpha} + \\mathbb{V}[\\zeta_{it}] + \\sigma^2_{\\epsilon} \\\\\n",
        "\\mathbb{C}(y_{it}, y_{it+s}) &= \\sigma^2_{\\alpha} + \\rho^s \\mathbb{V}[\\zeta_{it}]\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "**Step 1: Solve for $\\rho$**\n",
        "\n",
        "Taking differences of covariances at different lags:\n",
        "$$\n",
        "\\begin{align}\n",
        "\\mathbb{C}(y_{it}, y_{it+s+1}) - \\mathbb{C}(y_{it}, y_{it+s}) &= \\rho^{s+1}\\mathbb{V}[\\zeta_{it}] - \\rho^s\\mathbb{V}[\\zeta_{it}] \\\\\n",
        "&= \\rho^s(\\rho - 1)\\mathbb{V}[\\zeta_{it}]\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "Taking the ratio of consecutive differences:\n",
        "$$\n",
        "\\frac{\\mathbb{C}(y_{it}, y_{it+s+2}) - \\mathbb{C}(y_{it}, y_{it+s+1})}{\\mathbb{C}(y_{it}, y_{it+s+1}) - \\mathbb{C}(y_{it}, y_{it+s})} = \\frac{\\rho^{s+1}(\\rho - 1)\\mathbb{V}[\\zeta_{it}]}{\\rho^s(\\rho - 1)\\mathbb{V}[\\zeta_{it}]} = \\rho\n",
        "$$\n",
        "\n",
        "Therefore:\n",
        "$$\n",
        "\\rho = \\frac{\\mathbb{C}(y_{it}, y_{it+3}) - \\mathbb{C}(y_{it}, y_{it+2})}{\\mathbb{C}(y_{it}, y_{it+2}) - \\mathbb{C}(y_{it}, y_{it+1})}\n",
        "$$\n",
        "\n",
        "**Step 2: Solve for $\\mathbb{V}[\\zeta_{it}]$**\n",
        "\n",
        "Once we have $\\rho$, we can use:\n",
        "$$\n",
        "\\mathbb{V}[\\zeta_{it}] = \\frac{\\mathbb{C}(y_{it}, y_{it+1}) - \\sigma^2_{\\alpha}}{\\rho}\n",
        "$$\n",
        "\n",
        "But this requires $\\sigma^2_{\\alpha}$, so we first need another approach. Using:\n",
        "$$\n",
        "\\mathbb{C}(y_{it}, y_{it+2}) - \\mathbb{C}(y_{it}, y_{it+1}) = (\\rho^2 - \\rho)\\mathbb{V}[\\zeta_{it}]\n",
        "$$\n",
        "\n",
        "Therefore:\n",
        "$$\n",
        "\\mathbb{V}[\\zeta_{it}] = \\frac{\\mathbb{C}(y_{it}, y_{it+2}) - \\mathbb{C}(y_{it}, y_{it+1})}{\\rho^2 - \\rho} = \\frac{\\mathbb{C}(y_{it}, y_{it+2}) - \\mathbb{C}(y_{it}, y_{it+1})}{\\rho(\\rho - 1)}\n",
        "$$\n",
        "\n",
        "**Step 3: Solve for $\\sigma^2_{\\alpha}$**\n",
        "\n",
        "From the covariance formula:\n",
        "$$\n",
        "\\sigma^2_{\\alpha} = \\mathbb{C}(y_{it}, y_{it+1}) - \\rho \\mathbb{V}[\\zeta_{it}]\n",
        "$$\n",
        "\n",
        "**Step 4: Solve for $\\sigma^2_{\\epsilon}$**\n",
        "\n",
        "From the variance formula:\n",
        "$$\n",
        "\\sigma^2_{\\epsilon} = \\mathbb{V}[y_{it}] - \\sigma^2_{\\alpha} - \\mathbb{V}[\\zeta_{it}]\n",
        "$$\n",
        "\n",
        "**Step 5: Solve for $\\sigma^2_{\\eta}$**\n",
        "\n",
        "\n",
        "Since we assumed in this model that the initial value of $\\zeta_{i0}$ is drawn from the stationary distribution, we can use the AR(1) stationary variance formula:\n",
        "$$\n",
        "\\mathbb{V}[\\zeta_{it}] = \\frac{\\sigma^2_{\\eta}}{1 - \\rho^2}\n",
        "$$\n",
        "\n",
        "Therefore:\n",
        "$$\n",
        "\\sigma^2_{\\eta} = (1 - \\rho^2)\\mathbb{V}[\\zeta_{it}]\n",
        "$$\n",
        "\n",
        "Alternatively we could use that:\n",
        "$$\n",
        "\\mathbb{V}[y_{it+1}] = \\sigma^2_{\\alpha} + \\rho^2\\mathbb{V}[\\zeta_{it}] + \\sigma^2_{\\eta} + \\sigma^2_{\\epsilon}.\n",
        "$$\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Question 3: Estimating Parameters from PSID Data\n"
      ],
      "id": "093e2eac"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load the data\n",
        "d = CSV.read(\"../data/abb_aea_data.csv\", DataFrame)\n",
        "d[!, :logy] = log.(d.y);"
      ],
      "id": "7d707e75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "First, we need to account for the fact that PSID is biennial (every 2 years). This means we observe income at $t$, $t+2$, $t+4$, $t+6$, etc.\n"
      ],
      "id": "980e5aa5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Construct forward lags (accounting for biennial data)\n",
        "function forward_lag(d, l, var)\n",
        "    d_lag = @chain d begin\n",
        "        @select :person :year $var\n",
        "        @transform :year = :year .- l\n",
        "        @rename $(Symbol(var, \"_\", l)) = $var\n",
        "    end\n",
        "    d = leftjoin(d, d_lag, on=[:person, :year])\n",
        "    return d\n",
        "end\n",
        "\n",
        "d = forward_lag(d, 2, :logy)\n",
        "d = forward_lag(d, 4, :logy)\n",
        "d = forward_lag(d, 6, :logy)"
      ],
      "id": "b67d73a7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Demean by age to remove the $\\mu_t$ component:\n"
      ],
      "id": "e5831bf0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "d = @chain d begin\n",
        "    groupby(:age)\n",
        "    @transform :eps = :logy .- mean(:logy)\n",
        "end\n",
        "\n",
        "d = forward_lag(d, 2, :eps)\n",
        "d = forward_lag(d, 4, :eps)\n",
        "d = forward_lag(d, 6, :eps)"
      ],
      "id": "525740e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Calculate covariances:\n"
      ],
      "id": "5999e5a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cov_lag = pairwise(cov, eachcol(d[!, [:eps, :eps_2, :eps_4, :eps_6]]),\n",
        "                   skipmissing = :pairwise)[:, 1]\n",
        "\n",
        "println(\"Empirical moments:\")\n",
        "println(\"Var(y_t):           \", round(cov_lag[1], digits=4))\n",
        "println(\"Cov(y_t, y_{t+2}):  \", round(cov_lag[2], digits=4))\n",
        "println(\"Cov(y_t, y_{t+4}):  \", round(cov_lag[3], digits=4))\n",
        "println(\"Cov(y_t, y_{t+6}):  \", round(cov_lag[4], digits=4))"
      ],
      "id": "5c6bc481",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now estimate the parameters. Since PSID is biennial, our lags correspond to $s=2, 4, 6$ years. We need to adjust the formulas accordingly:\n",
        "\n",
        "For biennial data with lags $s = 2, 4, 6$:\n",
        "$$\n",
        "\\rho^{2} = \\frac{\\mathbb{C}(y_{it}, y_{it+6}) - \\mathbb{C}(y_{it}, y_{it+4})}{\\mathbb{C}(y_{it}, y_{it+4}) - \\mathbb{C}(y_{it}, y_{it+2})}\n",
        "$$\n"
      ],
      "id": "e45c0abd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Estimate ρ (accounting for biennial data - each lag is 2 years)\n",
        "# The formula gives us ρ^2, so we take the square root\n",
        "ρ_squared = (cov_lag[4] - cov_lag[3]) / (cov_lag[3] - cov_lag[2])\n",
        "ρ = sqrt(ρ_squared)\n",
        "\n",
        "println(\"\\nEstimated ρ: \", round(ρ, digits=4))"
      ],
      "id": "d3c61c9d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Estimate $\\mathbb{V}[\\zeta_{it}]$:\n",
        "\n",
        "For biennial data:\n",
        "$$\n",
        "\\mathbb{V}[\\zeta_{it}] = \\frac{\\mathbb{C}(y_{it}, y_{it+4}) - \\mathbb{C}(y_{it}, y_{it+2})}{\\rho^4 - \\rho^2}\n",
        "$$\n"
      ],
      "id": "bd95afe5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V_ζ = (cov_lag[3] - cov_lag[2]) / (ρ^4 - ρ^2)\n",
        "\n",
        "println(\"Estimated V[ζ]:     \", round(V_ζ, digits=4))"
      ],
      "id": "f030c325",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Estimate $\\sigma^2_{\\alpha}$:\n"
      ],
      "id": "0e36afd8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "σ2_α = cov_lag[2] - ρ^2 * V_ζ\n",
        "\n",
        "println(\"Estimated σ²_α:     \", round(σ2_α, digits=4))"
      ],
      "id": "35765e39",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Estimate $\\sigma^2_{\\epsilon}$:\n"
      ],
      "id": "a28a0835"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "σ2_ε = cov_lag[1] - σ2_α - V_ζ\n",
        "\n",
        "println(\"Estimated σ²_ε:     \", round(σ2_ε, digits=4))"
      ],
      "id": "96a7e97c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Estimate $\\sigma^2_{\\eta}$:\n"
      ],
      "id": "2a3da12b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "σ2_η = (1 - ρ^2) * V_ζ\n",
        "\n",
        "println(\"Estimated σ²_η:     \", round(σ2_η, digits=4))"
      ],
      "id": "e7372a7d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Calculate the mean income profile:\n"
      ],
      "id": "4620d924"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "var_by_age = @chain d begin\n",
        "    @subset .!ismissing.(:y)\n",
        "    groupby(:age)\n",
        "    @combine begin\n",
        "        :mean_logy = mean(log.(:y))\n",
        "        :n = length(:y)\n",
        "    end\n",
        "    @subset :n .> 100\n",
        "end\n",
        "\n",
        "μ_t = @chain var_by_age begin\n",
        "    @subset :age .>= 25 :age .< 65\n",
        "    @orderby :age\n",
        "    _[!, :mean_logy]\n",
        "end"
      ],
      "id": "5a14473c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Summary of estimated parameters:\n"
      ],
      "id": "8167ad33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results = DataFrame(\n",
        "    Parameter = [\"ρ\", \"σ²_ε\", \"σ²_η\", \"σ²_α\"],\n",
        "    Estimate = [ρ, σ2_ε, σ2_η, σ2_α]\n",
        ")\n",
        "\n",
        "display(results)"
      ],
      "id": "896f0a07",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now let's check how well our estimated model fits the empirical autocovariances:\n"
      ],
      "id": "ca660d9f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Predicted covariances from our model\n",
        "# Cov(y_t, y_{t+s}) = σ²_α + ρ^s * V[ζ]\n",
        "lag = [0, 2, 4, 6]\n",
        "cov_predicted = [σ2_α + ρ^s * V_ζ for s in lag]\n",
        "\n",
        "# Compare empirical vs predicted\n",
        "plot(lag, cov_lag,\n",
        "    label=\"Empirical\",\n",
        "    marker=:circle,\n",
        "    markersize=6,\n",
        "    linewidth=2,\n",
        "    xlabel=\"Lag (years)\",\n",
        "    ylabel=\"Cov(log yₜ, log yₜ₊ₛ)\",\n",
        "    title=\"Model Fit: Autocovariance Function\",\n",
        "    legend=:topright)\n",
        "plot!(lag, cov_predicted,\n",
        "    label=\"Model (AR1 + Fixed Effect)\",\n",
        "    marker=:square,\n",
        "    markersize=6,\n",
        "    linewidth=2,\n",
        "    linestyle=:dash)"
      ],
      "id": "d7ffc707",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The plot shows how well the model with fixed effects and AR(1) component fits the empirical autocovariance structure. Notice that the fixed effect $\\alpha_i$ creates a floor in the autocovariance function (at $\\sigma^2_\\alpha$), while the AR(1) component decays according to $\\rho^s$.\n",
        "\n",
        "# Question 4: Comparing ρ Estimates\n",
        "\n",
        "In [Recitation 4](../recitations/recitation-4.qmd), we estimated an AR(1) process without a permanent component and without measurement error:\n",
        "$$ y_{it} = \\mu_t + \\varepsilon_{it}, \\quad \\varepsilon_{t+1} = \\rho \\varepsilon_t + \\zeta_{t+1} $$\n",
        "\n",
        "The estimate was approximately $\\rho \\approx 0.82$, indicating lower persistence. \n",
        "\n",
        "Notice that $\\rho$ is identified by the rate of decay in the autocovariance *beyond* the first lag. There is a large drop between lags of 0 and 2 in the data, which the richer model can attribute to measurement error. The simpler model must fit this rate of decay by understating the persistence of $\\zeta_{it}$.\n",
        "\n",
        "\n",
        "# Question 5 (Extra Credit): Welfare Analysis with New Income Process\n",
        "\n",
        "We now repeat the welfare analysis from Recitation 4 using the new income process that includes permanent heterogeneity, AR(1) dynamics, and measurement error.\n"
      ],
      "id": "539de147"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Utility function\n",
        "utility(c, σ) = c^(1 - σ) / (1 - σ)\n",
        "\n",
        "# Tauchen method (from recitation)\n",
        "function tauchen(N, ρ, σ)\n",
        "    σ_y = σ / sqrt(1 - ρ^2)\n",
        "    y_max = 3. * σ_y\n",
        "    y_min = -3. * σ_y\n",
        "    grid = range(y_min, y_max, length=N)\n",
        "    step = (y_max - y_min) / (N - 1)\n",
        "    Π = zeros(N, N)\n",
        "    d = Normal(0, 1)\n",
        "\n",
        "    for i in 1:N\n",
        "        for j in 1:N\n",
        "            if j == 1\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ)\n",
        "            elseif j == N\n",
        "                Π[j, i] = 1 - cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            else\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ) -\n",
        "                         cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return collect(grid), Π\n",
        "end\n",
        "\n",
        "# Function to approximate the income process\n",
        "function approx_income_process(N, ρ, σ, σ_α)\n",
        "    # Use tauchen method to approximate the AR(1) component\n",
        "    egrid, Π = tauchen(N, ρ, σ)\n",
        "    agrid = [-sqrt(3/2)*σ_α, 0., sqrt(3/2)*σ_α]\n",
        "    # Construct a larger grid of α .+ egrid for each α\n",
        "    grid = [α + e for α in agrid for e in egrid]\n",
        "    # Create a larger transition matrix where the\n",
        "    # probability of moving from α to any other α' is zero\n",
        "    Π = kron(I(3), Π)\n",
        "    return grid, Π\n",
        "end"
      ],
      "id": "e7c8b9f4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Set up the income process using our estimated parameters:\n"
      ],
      "id": "eec3ad6c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Use estimated parameters from Question 3\n",
        "N_AR1 = 5  # Grid points for AR(1) component\n",
        "σ_ζ = sqrt(σ2_η)  # Innovation SD for AR(1)\n",
        "σ_α_est = sqrt(σ2_α)  # SD of fixed effect\n",
        "\n",
        "# Approximate the income process\n",
        "egrid, Π = approx_income_process(N_AR1, ρ, σ_ζ, σ_α_est)\n",
        "\n",
        "# Note: We ignore ε (measurement error) as it doesn't affect real income\n",
        "\n",
        "println(\"Income process approximation:\")\n",
        "println(\"Number of states: \", length(egrid))\n",
        "println(\"Grid range: [\", round(minimum(egrid), digits=3), \", \",\n",
        "        round(maximum(egrid), digits=3), \"]\")"
      ],
      "id": "879f70d3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Set up the model:\n"
      ],
      "id": "a2e06dd6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Model parameters\n",
        "T = 40  # Working life\n",
        "age_start = 25\n",
        "\n",
        "# Create income grid with age-varying mean\n",
        "K_y = length(egrid)\n",
        "income_grid = zeros(K_y, T)\n",
        "for t in 1:T\n",
        "    for i in 1:K_y\n",
        "        income_grid[i, t] = μ_t[t] + egrid[i]\n",
        "    end\n",
        "end\n",
        "\n",
        "# Solve the model\n",
        "function solve_model(p)\n",
        "    (;T, Π, asset_grid) = p\n",
        "    K_a = length(asset_grid)\n",
        "    K_y = size(Π, 1)\n",
        "    V = zeros(K_y, K_a, T+1)\n",
        "    A = zeros(K_y, K_a, T)\n",
        "    for t in reverse(1:T)\n",
        "        iterate_value_function!(p, V, A, t)\n",
        "    end\n",
        "    return (;V, A)\n",
        "end\n",
        "\n",
        "function iterate_value_function!(p, V, A, t)\n",
        "    for ai in axes(V, 2), yi in axes(V, 1)\n",
        "        v, a_next = solve_value(ai, yi, V, p, t)\n",
        "        V[yi, ai, t] = v\n",
        "        A[yi, ai, t] = a_next\n",
        "    end\n",
        "end\n",
        "\n",
        "function solve_value(ai, yi, V, p, t)\n",
        "    (;σ, β, Π, r, asset_grid, income_grid, net_income) = p\n",
        "    a = asset_grid[ai]\n",
        "    y = exp(income_grid[yi, t])\n",
        "    y_net = net_income(y)\n",
        "    vmax = -Inf\n",
        "    amax = 0\n",
        "    for ai_next in eachindex(asset_grid)\n",
        "        a_next = asset_grid[ai_next]\n",
        "        c = y_net + a - a_next/(1+r)\n",
        "        if c > 0\n",
        "            @views v = utility(c, σ) + β * dot(Π[:, yi], V[:, ai_next, t+1])\n",
        "            if v > vmax\n",
        "                vmax = v\n",
        "                amax = a_next\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return vmax, amax\n",
        "end\n",
        "\n",
        "# Tax functions\n",
        "no_tax(x) = x\n",
        "progressive_tax(x, λ, τ) = λ * x^(1-τ)\n",
        "\n",
        "# Model parameters\n",
        "p = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0, 200, 100),\n",
        "    income_grid,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π,\n",
        "    σ = 2.,\n",
        "    net_income = no_tax\n",
        ")"
      ],
      "id": "a178fabb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Solve for the progressive tax parameter:\n"
      ],
      "id": "a97238be"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_steady_state(Π)\n",
        "    K = size(Π, 2)\n",
        "    vals, e = eigen(Π)\n",
        "    return e[:, K] ./ sum(e[:, K])\n",
        "end\n",
        "\n",
        "function solve_lambda(τ, ygrid, pi_star)\n",
        "    return dot(pi_star, ygrid) / dot(pi_star, ygrid.^(1-τ))\n",
        "end\n",
        "\n",
        "# Solve for stationary distribution\n",
        "pi_star = solve_steady_state(p.Π)\n",
        "\n",
        "# Choose progressivity\n",
        "τ = 0.2\n",
        "\n",
        "# Solve for λ\n",
        "λ = solve_lambda(τ, exp.(income_grid[:, 1]), pi_star)\n",
        "\n",
        "println(\"\\nProgressive tax parameters:\")\n",
        "println(\"τ = \", τ)\n",
        "println(\"λ = \", round(λ, digits=3))"
      ],
      "id": "76483708",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Solve both models:\n"
      ],
      "id": "1f662994"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "println(\"\\nSolving model without taxes...\")\n",
        "model0 = solve_model(p)\n",
        "\n",
        "p_tax = (;p..., net_income = x -> progressive_tax(x, λ, τ))\n",
        "\n",
        "println(\"Solving model with progressive taxes...\")\n",
        "model1 = solve_model(p_tax)\n",
        "\n",
        "println(\"Done!\")"
      ],
      "id": "5ca98734",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Welfare decomposition:\n"
      ],
      "id": "613c5c1b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "(;σ, β) = p\n",
        "\n",
        "# Calculate average income\n",
        "C = dot(pi_star, exp.(p.income_grid[:, 1]))\n",
        "\n",
        "# Certainty equivalents by state\n",
        "cbar0 = ((1-σ) * (1-β) / (1-β^T) * model0.V[:, 1, 1]).^(1/(1-σ))\n",
        "cbar1 = ((1-σ) * (1-β) / (1-β^T) * model1.V[:, 1, 1]).^(1/(1-σ))\n",
        "\n",
        "# Average certainty equivalents\n",
        "Cbar0 = dot(pi_star, cbar0)\n",
        "Cbar1 = dot(pi_star, cbar1)\n",
        "\n",
        "# Aggregate welfare\n",
        "W0 = dot(pi_star, model0.V[:, 1, 1])\n",
        "W1 = dot(pi_star, model1.V[:, 1, 1])\n",
        "\n",
        "# Value under perfect insurance\n",
        "V_cert(x) = (1-β^T) / (1-β) * utility(x, σ)\n",
        "\n",
        "# Decomposition\n",
        "ω = (W1/W0)^(1/(1-σ)) - 1\n",
        "γ = (V_cert(Cbar1) / V_cert(Cbar0))^(1/(1-σ)) - 1\n",
        "α = ((W1 / V_cert(Cbar1)) / (W0 / V_cert(Cbar0)))^(1/(1-σ)) - 1\n",
        "\n",
        "println(\"\\n\" * \"=\"^60)\n",
        "println(\"WELFARE DECOMPOSITION WITH NEW INCOME PROCESS\")\n",
        "println(\"=\"^60)\n",
        "println(\"Total welfare gain (ω):           \", round(ω*100, digits=2), \"%\")\n",
        "println(\"Insurance component (γ):          \", round(γ*100, digits=2), \"%\")\n",
        "println(\"Redistribution component (α):     \", round(α*100, digits=2), \"%\")\n",
        "println(\"\\nVerification: (1+γ)(1+α) = \", round((1+γ)*(1+α), digits=4),\n",
        "        \" ≈ \", round(1+ω, digits=4))\n",
        "\n",
        "# Display as table\n",
        "results_welfare = DataFrame(\n",
        "    Component = [\"Total (1+ω)\", \"Insurance (1+γ)\", \"Redistribution (1+α)\"],\n",
        "    Value = [1+ω, 1+γ, 1+α],\n",
        "    Percentage_gain = [ω*100, γ*100, α*100]\n",
        ")"
      ],
      "id": "2b125eba",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Comparison with Recitation 4:**\n",
        "\n",
        "In Recitation 4 we estimated a consumption equivalent welfare gain of 28% that was largely due to insurance (26%). Here we are seeing a 17% consumption equivalent increase in welfare that is largely attributable to redistribution (10%). This makes sense: in the previous case we did not allow for permanent differences among individuals, and so progressive taxation provided mostly insurance against less persistent shocks to income."
      ],
      "id": "ed22256a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}