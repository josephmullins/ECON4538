{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Recitation 4\"\n",
        "bibliography: ../reading_list.bib\n",
        "---"
      ],
      "id": "672a765a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using DataFrames, DataFramesMeta, CSV, StatsPlots, LinearAlgebra, Distributions, StatsBase"
      ],
      "id": "8bc52455",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Calibrating Income Processes from Data\n",
        "\n",
        "In [recitation 3](../recitations/recitation-3.qmd) we studied the welfare implications of tax and transfer programs using a stylized income process. Today we'll calibrate a more realistic income process using data from @ABB_2018, and then evaluate the welfare effects of progressive taxation under this calibrated process.\n",
        "\n",
        "## Loading and Exploring the Data\n",
        "\n",
        "The data come from the PSID and contain information on income over the life cycle. Let's start by loading the data and examining some basic patterns.\n"
      ],
      "id": "1b2cee23"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "d = CSV.read(\"../data/abb_aea_data.csv\", DataFrame)\n",
        "d[!,:logy] = log.(d.y);"
      ],
      "id": "b4d68a64",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "First, let's look at how the variance of log income evolves with age:\n"
      ],
      "id": "93049806"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "var_by_age = @chain d begin\n",
        "    @subset .!ismissing.(:y)\n",
        "    groupby(:age)\n",
        "    @combine begin\n",
        "        :var_logy = var(log.(:y))\n",
        "        :mean_logy = mean(log.(:y))\n",
        "        :n = length(:y)\n",
        "    end\n",
        "    @subset :n .> 100\n",
        "end\n",
        "\n",
        "@df var_by_age plot(:age, :var_logy,\n",
        "    xlabel=\"Age\",\n",
        "    ylabel=\"Variance of log income\",\n",
        "    title=\"Life-Cycle Profile of Income Variance\",\n",
        "    legend=false,\n",
        "    linewidth=2)"
      ],
      "id": "f8f8f576",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The variance of log income increases substantially over the life cycle. This is consistent with income shocks being persistent: the variance accumulates as people age.\n",
        "\n",
        "## Calculating Autocovariances\n",
        "\n",
        "To understand the persistence of income shocks, we need to calculate the covariance of income at different lags. The code below constructs forward lags and calculates covariances.\n"
      ],
      "id": "0ab3c55b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# construct forward-lags\n",
        "function forward_lag(d, l, var)\n",
        "    d_lag = @chain d begin\n",
        "        @select :person :year $var\n",
        "        @transform :year = :year .- l\n",
        "        @rename $(Symbol(var,\"_\",l)) = $var\n",
        "    end\n",
        "    d = leftjoin(d, d_lag, on=[:person,:year])\n",
        "    return d\n",
        "end\n",
        "\n",
        "d = forward_lag(d, 2, :logy);\n",
        "d = forward_lag(d, 4, :logy);\n",
        "d = forward_lag(d, 6, :logy);"
      ],
      "id": "f7356bf3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now let's calculate the covariances at different lags:\n"
      ],
      "id": "22ef98fa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Covariance of log income with itself at different lags\n",
        "cov_data = pairwise(cov, eachcol(d[!,[:logy,:logy_2,:logy_4,:logy_6]]),\n",
        "                    skipmissing = :pairwise)\n",
        "\n",
        "# Extract covariances with current log income\n",
        "lag = [0, 2, 4, 6]\n",
        "cov_lag = cov_data[:,1]\n",
        "\n",
        "display(DataFrame(lag = lag, covariance = cov_lag))\n",
        "\n",
        "# Plot the covariance function\n",
        "plot(lag, cov_lag,\n",
        "    xlabel=\"Lag (years)\",\n",
        "    ylabel=\"Cov(log yₜ, log yₜ₊ₛ)\",\n",
        "    title=\"Autocovariance Function of Log Income\",\n",
        "    marker=:circle,\n",
        "    markersize=6,\n",
        "    linewidth=2,\n",
        "    legend=false)"
      ],
      "id": "4c58fc72",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Covariances of Income Growth\n",
        "\n",
        "We can also look at the covariances of income growth over different periods:\n"
      ],
      "id": "923f30d0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "d_growth = @chain d begin\n",
        "    @transform begin\n",
        "        :Dlogy_2 = :logy_2 .- :logy\n",
        "        :Dlogy_4 = :logy_4 .- :logy_2\n",
        "        :Dlogy_6 = :logy_6 .- :logy_4\n",
        "    end\n",
        "    @select :Dlogy_2 :Dlogy_4 :Dlogy_6\n",
        "end\n",
        "\n",
        "cov_growth = pairwise(cov, eachcol(d_growth), skipmissing = :pairwise)\n",
        "\n",
        "println(\"Covariance matrix of income growth:\")\n",
        "display(cov_growth)"
      ],
      "id": "57286587",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The diagonal elements show the variance of 2-year income changes. The off-diagonal elements show how correlated income changes are across different periods.\n",
        "\n",
        "## Calibrating an AR(1) Process\n",
        "\n",
        "Now suppose that income in the model follows an AR(1) process:\n",
        "\n",
        "$$ y_{it} = \\mu_{t} + \\varepsilon_{it} $$\n",
        "\n",
        "where:\n",
        "\n",
        "$$ \\varepsilon_{t+1} = \\rho \\varepsilon_t + \\zeta_{t+1}, \\quad \\zeta_{t+1} \\sim N(0, \\sigma^2_\\zeta) $$\n",
        "\n",
        "We can construct the residuals $\\varepsilon$ by first de-meaning by age. We take lags as well:\n"
      ],
      "id": "a430759e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "d = @chain d begin\n",
        "    groupby(:age)\n",
        "    @transform :eps = :logy .- mean(:logy)\n",
        "end\n",
        "\n",
        "d = forward_lag(d, 2, :eps);\n",
        "d = forward_lag(d, 4, :eps);\n",
        "d = forward_lag(d, 6, :eps);\n"
      ],
      "id": "600728d5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Recall that:\n",
        "\n",
        "$$ \\text{Cov}(\\varepsilon_t, \\varepsilon_{t+s}) = \\rho^{s}\\text{Var}(\\varepsilon_{t}).$$\n",
        "\n",
        "This means that there are a multiple ways to estimate the persistence parameter $\\rho$, using different orders of lags.\n",
        "\n",
        "There are also multiple ways to estimate $\\sigma^2_{\\zeta}$. The simplest way is to assume that $\\varepsilon$ is in its stationary distribution which gives:\n",
        "\n",
        "\n",
        "$$ \\text{Var}(\\varepsilon_{it}) = \\sigma^2_{\\zeta} / (1 - \\rho^2) .$$\n",
        "\n",
        "\n",
        "Below is code to calculate the covariance at different lags and estimate $\\rho$ as the mean of three alternative estimators.\n"
      ],
      "id": "6fa80114"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cov_lag = pairwise(cov, eachcol(d[!,[:eps,:eps_2,:eps_4,:eps_6]]),\n",
        "                    skipmissing = :pairwise)[:,1]\n",
        "\n",
        "\n",
        "# Estimate ρ from the ratio of covariances at different lags\n",
        "ρ_est_1 = sqrt(cov_lag[2] / cov_lag[1])  # (Cov(t,t+2) / Var(t))^(1/2)\n",
        "ρ_est_2 = (cov_lag[3] / cov_lag[1])^(1/4)  # (Cov(t,t+4) / Var(t))^(1/4)\n",
        "ρ_est_3 = (cov_lag[4] / cov_lag[1])^(1/6)  # (Cov(t,t+6) / Var(t))^(1/6)\n",
        "\n",
        "ρ = mean([ρ_est_1, ρ_est_2, ρ_est_3])\n",
        "\n",
        "println(\"Estimated persistence: ρ = \", round(ρ, digits=3))\n",
        "\n",
        "# Given ρ, we can back out the innovation variance\n",
        "σ_ε = sqrt(cov_lag[1])  # Unconditional SD\n",
        "σ_ζ = σ_ε * sqrt(1 - ρ^2)  # Innovation SD\n",
        "\n",
        "println(\"Unconditional SD: σ_ε = \", round(σ_ε, digits=3))\n",
        "println(\"Innovation SD: σ_ζ = \", round(σ_ζ, digits=3))"
      ],
      "id": "a371780b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's check how well our calibrated AR(1) matches the empirical covariances:\n"
      ],
      "id": "36122184"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Predicted covariances from AR(1)\n",
        "σ2_ε = σ_ε^2\n",
        "cov_predicted = [ρ^s * σ2_ε for s in lag]\n",
        "\n",
        "# Plot comparison\n",
        "plot(lag, cov_lag,\n",
        "    label=\"Data\",\n",
        "    marker=:circle,\n",
        "    markersize=6,\n",
        "    linewidth=2,\n",
        "    xlabel=\"Lag (years)\",\n",
        "    ylabel=\"Covariance\",\n",
        "    title=\"AR(1) Fit to Autocovariance Function\")\n",
        "plot!(lag, cov_predicted,\n",
        "    label=\"AR(1) model\",\n",
        "    marker=:square,\n",
        "    markersize=6,\n",
        "    linewidth=2,\n",
        "    linestyle=:dash)"
      ],
      "id": "83a2ba9e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Notice**: the autovariance does not decay as quickly in the data as in the model. Could individual fixed effects explain this pattern?\n",
        "\n",
        "## Age Profile of Mean Income\n",
        "\n",
        "The data also show that mean income varies systematically with age. Let's extract this profile:\n"
      ],
      "id": "9988cb5d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "@df var_by_age plot(:age, :mean_logy,\n",
        "    xlabel=\"Age\",\n",
        "    ylabel=\"Mean log income\",\n",
        "    title=\"Life-Cycle Profile of Mean Log Income\",\n",
        "    legend=false,\n",
        "    linewidth=2,\n",
        "    marker=:circle)"
      ],
      "id": "38a5c0dc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "For the model, we want mean of log wages between 25 and 65.\n"
      ],
      "id": "3c18b588"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "μ_t = @chain var_by_age begin\n",
        "    @subset :age.>=25 :age.<65\n",
        "    @orderby :age\n",
        "    _[!,:mean_logy]\n",
        "end"
      ],
      "id": "98bc66ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Welfare Analysis with Calibrated Income Process\n",
        "\n",
        "Now we'll use the calibrated income process to evaluate the welfare effects of progressive taxation. We'll use the same model structure as in recitation 3.\n",
        "\n",
        "## Model Setup\n"
      ],
      "id": "ba7149dc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# utility\n",
        "utility(c, σ) = c^(1 - σ) / (1 - σ)\n",
        "\n",
        "# tauchen method\n",
        "function tauchen(N, ρ, σ)\n",
        "    # Unconditional standard deviation of the process\n",
        "    σ_y = σ / sqrt(1 - ρ^2)\n",
        "\n",
        "    # Create the grid\n",
        "    y_max = 3. * σ_y\n",
        "    y_min = - 3. * σ_y\n",
        "    grid = range(y_min, y_max, length=N)\n",
        "\n",
        "    # Step size\n",
        "    step = (y_max - y_min) / (N - 1)\n",
        "\n",
        "    # Initialize transition matrix\n",
        "    Π = zeros(N, N)\n",
        "\n",
        "    # Standard normal distribution\n",
        "    d = Normal(0, 1)\n",
        "\n",
        "    # Fill in the transition matrix\n",
        "    for i in 1:N\n",
        "        for j in 1:N\n",
        "            if j == 1\n",
        "                # Probability of transitioning to the lowest state\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ)\n",
        "            elseif j == N\n",
        "                # Probability of transitioning to the highest state\n",
        "                Π[j, i] = 1 - cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            else\n",
        "                # Probability of transitioning to intermediate states\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ) -\n",
        "                         cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return collect(grid), Π\n",
        "end\n",
        "\n",
        "# solve the model\n",
        "function solve_model(p)\n",
        "    (;T, Π, asset_grid) = p\n",
        "    K_a = length(asset_grid)\n",
        "    K_y = size(Π, 1)\n",
        "    V = zeros(K_y, K_a, T+1)\n",
        "    A = zeros(K_y, K_a, T)\n",
        "    for t in reverse(1:T)\n",
        "        iterate_value_function!(p, V, A, t)\n",
        "    end\n",
        "    return (;V, A)\n",
        "end\n",
        "\n",
        "function iterate_value_function!(p, V, A, t)\n",
        "    for ai in axes(V, 2), yi in axes(V, 1)\n",
        "        v, a_next = solve_value(ai, yi, V, p, t)\n",
        "        V[yi, ai, t] = v\n",
        "        A[yi, ai, t] = a_next\n",
        "    end\n",
        "end\n",
        "\n",
        "function solve_value(ai, yi, V, p, t)\n",
        "    (;σ, β, Π, r, asset_grid, income_grid, net_income) = p\n",
        "    a = asset_grid[ai]\n",
        "    y = exp(income_grid[yi, t])\n",
        "    y_net = net_income(y)\n",
        "    vmax = -Inf\n",
        "    amax = 0\n",
        "    for ai_next in eachindex(asset_grid)\n",
        "        a_next = asset_grid[ai_next]\n",
        "        c = y_net + a - a_next/(1+r)\n",
        "        if c > 0\n",
        "            @views v = utility(c, σ) + β * dot(Π[:, yi], V[:, ai_next, t+1])\n",
        "            if v > vmax\n",
        "                vmax = v\n",
        "                amax = a_next\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return vmax, amax\n",
        "end"
      ],
      "id": "b2860472",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Tax Functions\n"
      ],
      "id": "6d07c728"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "no_tax(x) = x\n",
        "\n",
        "progressive_tax(x, λ, τ) = λ * x^(1-τ)"
      ],
      "id": "037a4359",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Setting Up the Calibrated Model\n",
        "\n",
        "Now we use the calibrated parameters from the data:\n"
      ],
      "id": "9b14688a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Use calibrated parameters\n",
        "N_states = 7\n",
        "egrid, Π = tauchen(N_states, ρ, σ_ζ)\n",
        "\n",
        "# Model periods: assume working life from age 25 to 65\n",
        "T = 40\n",
        "age_start = 25\n",
        "\n",
        "# Create income grid with age-varying mean\n",
        "income_grid = zeros(N_states, T)\n",
        "for t in 1:T\n",
        "    age = age_start + t - 1\n",
        "    for i in 1:N_states\n",
        "        income_grid[i, t] = μ_t[t] + egrid[i]\n",
        "    end\n",
        "end\n",
        "\n",
        "# Plot the income grid to visualize\n",
        "plot(age_start:(age_start+T-1), exp.(income_grid[1, :]),\n",
        "    label=\"Lowest state\",\n",
        "    xlabel=\"Age\",\n",
        "    ylabel=\"Income (thousands)\",\n",
        "    title=\"Income Paths by Shock State\",\n",
        "    linewidth=2)\n",
        "plot!(age_start:(age_start+T-1), exp.(income_grid[4, :]),\n",
        "    label=\"Middle state\",\n",
        "    linewidth=2)\n",
        "plot!(age_start:(age_start+T-1), exp.(income_grid[N_states, :]),\n",
        "    label=\"Highest state\",\n",
        "    linewidth=2)"
      ],
      "id": "19b2c18e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Model Parameters\n"
      ],
      "id": "bde231d6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "p = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0, 200, 100),\n",
        "    income_grid,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π,\n",
        "    σ = 2.,\n",
        "    net_income = no_tax\n",
        ")"
      ],
      "id": "8b64e1f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Calibrating Progressive Taxation\n",
        "\n",
        "We need to choose $\\lambda$ to ensure budget balance:\n"
      ],
      "id": "7a595eef"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_steady_state(Π)\n",
        "    K = size(Π, 2)\n",
        "    vals, e = eigen(Π)\n",
        "    return e[:, K] ./ sum(e[:, K])\n",
        "end\n",
        "\n",
        "function solve_lambda(τ, ygrid, pi_star)\n",
        "    return dot(pi_star, ygrid) / dot(pi_star, ygrid.^(1-τ))\n",
        "end\n",
        "\n",
        "# Solve for stationary distribution\n",
        "pi_star = solve_steady_state(p.Π)\n",
        "\n",
        "# Choose progressivity\n",
        "τ = 0.2\n",
        "\n",
        "# Solve for λ using income in first period\n",
        "λ = solve_lambda(τ, exp.(income_grid[:, 1]), pi_star)\n",
        "\n",
        "println(\"Tax progressivity parameter: τ = \", τ)\n",
        "println(\"Tax scale parameter: λ = \", round(λ, digits=3))"
      ],
      "id": "eb38c3ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Solving Both Models\n"
      ],
      "id": "03d485a3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "println(\"Solving model without taxes...\")\n",
        "model0 = solve_model(p)\n",
        "\n",
        "p_tax = (;p..., net_income = x -> progressive_tax(x, λ, τ))\n",
        "\n",
        "println(\"Solving model with progressive taxes...\")\n",
        "model1 = solve_model(p_tax)\n",
        "\n",
        "println(\"Done!\")"
      ],
      "id": "5b6dd746",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Welfare Comparison\n",
        "\n",
        "Let's compare the value functions:\n"
      ],
      "id": "ce2276bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plot(model0.V[:, 1, 1],\n",
        "    label=\"No taxes\",\n",
        "    xlabel=\"Income shock state\",\n",
        "    ylabel=\"Value\",\n",
        "    title=\"Value Function at Period 1, Zero Assets\",\n",
        "    marker=:circle,\n",
        "    linewidth=2,\n",
        "    legend=:bottomright)\n",
        "plot!(model1.V[:, 1, 1],\n",
        "    label=\"Progressive taxes (τ=$τ)\",\n",
        "    marker=:square,\n",
        "    linewidth=2)"
      ],
      "id": "a18acad0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Welfare Decomposition\n",
        "\n",
        "Following recitation 3, we decompose the welfare gain into insurance and redistribution components:\n"
      ],
      "id": "1d274aa0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "(;σ, β) = p\n",
        "\n",
        "# Calculate average income at period 1\n",
        "C = dot(pi_star, exp.(p.income_grid[:, 1]))\n",
        "\n",
        "# Certainty equivalents by state\n",
        "cbar0 = ((1-σ) * (1-β) / (1-β^T) * model0.V[:, 1, 1]).^(1/(1-σ))\n",
        "cbar1 = ((1-σ) * (1-β) / (1-β^T) * model1.V[:, 1, 1]).^(1/(1-σ))\n",
        "\n",
        "# Average certainty equivalents\n",
        "Cbar0 = dot(pi_star, cbar0)\n",
        "Cbar1 = dot(pi_star, cbar1)\n",
        "\n",
        "# Aggregate welfare\n",
        "W0 = dot(pi_star, model0.V[:, 1, 1])\n",
        "W1 = dot(pi_star, model1.V[:, 1, 1])\n",
        "\n",
        "# Value under perfect insurance\n",
        "V_cert(x) = (1-β^T) / (1-β) * utility(x, σ)\n",
        "\n",
        "# Decomposition\n",
        "ω = (W1/W0)^(1/(1-σ)) - 1\n",
        "γ = (V_cert(Cbar1) / V_cert(Cbar0))^(1/(1-σ)) - 1\n",
        "α = ((W1 / V_cert(Cbar1)) / (W0 / V_cert(Cbar0)))^(1/(1-σ)) - 1\n",
        "\n",
        "println(\"\\nWelfare Decomposition:\")\n",
        "println(\"=\" ^ 50)\n",
        "println(\"Total welfare gain:        \", round((1+ω-1)*100, digits=2), \"%\")\n",
        "println(\"Insurance component:       \", round((1+γ-1)*100, digits=2), \"%\")\n",
        "println(\"Redistribution component:  \", round((1+α-1)*100, digits=2), \"%\")\n",
        "println(\"\\nVerification: (1+γ)(1+α) = \", round((1+γ)*(1+α), digits=4), \" ≈ \", round(1+ω, digits=4))\n",
        "\n",
        "# Display as table\n",
        "results = DataFrame(\n",
        "    Component = [\"Total (1+ω)\", \"Insurance (1+γ)\", \"Redistribution (1+α)\"],\n",
        "    Value = [1+ω, 1+γ, 1+α],\n",
        "    Percentage = [ω*100, γ*100, α*100]\n",
        ")\n",
        "display(results)"
      ],
      "id": "5ae9a263",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Additional Exercise\n",
        "\n",
        "Try varying the tax progressivity parameter τ. How do the insurance and redistribution components change as τ increases from 0 to 0.4?\n"
      ],
      "id": "dd5a92dc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Exercise: Welfare gains for different tax progressivity levels\n",
        "τ_values = 0.0:0.05:0.4\n",
        "welfare_results = zeros(length(τ_values), 3)\n",
        "\n",
        "for (i, τ_val) in enumerate(τ_values)\n",
        "    if τ_val == 0\n",
        "        welfare_results[i, :] .= [0.0, 0.0, 0.0]\n",
        "        continue\n",
        "    end\n",
        "\n",
        "    λ_val = solve_lambda(τ_val, exp.(income_grid[:, 1]), pi_star)\n",
        "    p_temp = (;p..., net_income = x -> progressive_tax(x, λ_val, τ_val))\n",
        "    model_temp = solve_model(p_temp)\n",
        "\n",
        "    W_temp = dot(pi_star, model_temp.V[:, 1, 1])\n",
        "    cbar_temp = ((1-σ) * (1-β) / (1-β^T) * model_temp.V[:, 1, 1]).^(1/(1-σ))\n",
        "    Cbar_temp = dot(pi_star, cbar_temp)\n",
        "\n",
        "    ω_temp = (W_temp/W0)^(1/(1-σ)) - 1\n",
        "    γ_temp = (V_cert(Cbar_temp) / V_cert(Cbar0))^(1/(1-σ)) - 1\n",
        "    α_temp = ((W_temp / V_cert(Cbar_temp)) / (W0 / V_cert(Cbar0)))^(1/(1-σ)) - 1\n",
        "\n",
        "    welfare_results[i, :] = [ω_temp*100, γ_temp*100, α_temp*100]\n",
        "end\n",
        "\n",
        "plot(τ_values, welfare_results[:, 1],\n",
        "    label=\"Total welfare gain\",\n",
        "    xlabel=\"Tax progressivity (τ)\",\n",
        "    ylabel=\"Welfare gain (%)\",\n",
        "    title=\"Welfare Effects of Tax Progressivity\",\n",
        "    linewidth=2.5,\n",
        "    legend=:topleft)\n",
        "plot!(τ_values, welfare_results[:, 2],\n",
        "    label=\"Insurance component\",\n",
        "    linewidth=2,\n",
        "    linestyle=:dash)\n",
        "plot!(τ_values, welfare_results[:, 3],\n",
        "    label=\"Redistribution component\",\n",
        "    linewidth=2,\n",
        "    linestyle=:dot)"
      ],
      "id": "25a74cff",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}