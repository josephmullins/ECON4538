{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Recitation 2\"\n",
        "bibliography: ../reading_list.bib\n",
        "---"
      ],
      "id": "8902c748"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using LinearAlgebra, Plots"
      ],
      "id": "d76b7058",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Welfare Implications of Income Risk\n",
        "\n",
        "In class, we concluded our section on trends in inequality by thinking about the implications for welfare and policy. Today we'll use a life-cycle savings model to study the welfare implications of different models of wage risk.\n",
        "\n",
        "## Model\n",
        "\n",
        "Let's assume that individuals live for $T$ periods. They face an income process that follows:\n",
        "\n",
        "$$ \\log(y_{it}) = \\mu_{t} + \\varepsilon_{it} $$\n",
        "\n",
        "where\n",
        "\n",
        "$$ \\varepsilon_{it} = \\rho \\varepsilon_{it-1} + \\zeta_{it},\\ \\zeta_{it} \\sim \\mathcal{N}(0,\\sigma^2_{\\zeta}).$$\n",
        "\n",
        "We assume a single risk-free asset with a rate of return $r$, so that the model can be phrased recursively:\n",
        "\n",
        "$$ V_{t}(a,y) = \\max_{a^\\prime}\\left\\{u(y + a - (1+r)^{-1}a^\\prime) + \\beta \\mathbb{E}_{y'}V_{t+1}(a',y') \\right\\} $$\n",
        "\n",
        "with $V_{T}=0$.\n",
        "\n",
        "We assume that utility $u$ is of the CRRA type, so we can write the function as:\n"
      ],
      "id": "d573ea18"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "utility(c,σ) = c^(1 - σ) / (1 - σ)"
      ],
      "id": "85e55b36",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that $\\mu_{t}$ is the mean of log income and can evolve with the age $t$ of the agent, but this *life-cycle profile* in wages is known. $\\varepsilon$ is the unknown component of income and the source of risk in the model.\n",
        "\n",
        "## Approximating the income process\n",
        "\n",
        "There are a number of methods for approximating the **AR(1) process** for income outlined above using a discrete state Markov process. A popular version is Tauchen's method. The code below is a function to produce a transition matrix $\\Pi$ and a grid of values that approximates the variance and autocovariance of an AR(1) process.\n"
      ],
      "id": "eca3fddb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Distributions\n",
        "\n",
        "function tauchen(N, ρ, σ)\n",
        "    # Unconditional standard deviation of the process\n",
        "    σ_y = σ / sqrt(1 - ρ^2)\n",
        "\n",
        "    # Create the grid\n",
        "    y_max = 3. * σ_y\n",
        "    y_min = - 3. * σ_y\n",
        "    grid = range(y_min, y_max, length=N)\n",
        "\n",
        "    # Step size\n",
        "    step = (y_max - y_min) / (N - 1)\n",
        "\n",
        "    # Initialize transition matrix\n",
        "    Π = zeros(N, N)\n",
        "\n",
        "    # Standard normal distribution\n",
        "    d = Normal(0, 1)\n",
        "\n",
        "    # Fill in the transition matrix\n",
        "    for i in 1:N\n",
        "        for j in 1:N\n",
        "            if j == 1\n",
        "                # Probability of transitioning to the lowest state\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ)\n",
        "            elseif j == N\n",
        "                # Probability of transitioning to the highest state\n",
        "                Π[j, i] = 1 - cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            else\n",
        "                # Probability of transitioning to intermediate states\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ) -\n",
        "                         cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return collect(grid), Π\n",
        "end"
      ],
      "id": "d3c4be2f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is going to produce a matrix where $\\Pi[j,i]$ contains the probability of moving to state $j$ when currently in state $i$.\n",
        "\n",
        "## Solving the Model\n",
        "\n",
        "This model can be solved almost identically to the infinite horizon version. We can start by writing a function to solve the maximization problem given a point in the asset and income grid.\n"
      ],
      "id": "a205731a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_value(ai,yi,V,p,t)\n",
        "    (;σ,β,Π,r,asset_grid,income_grid) = p\n",
        "    a = asset_grid[ai]\n",
        "    y = exp(income_grid[yi,t])\n",
        "    vmax = -Inf\n",
        "    amax = 0\n",
        "    for ai_next in eachindex(asset_grid)\n",
        "        a_next = asset_grid[ai_next]\n",
        "        c = y + a - a_next/(1+r)\n",
        "        if c>0\n",
        "            @views v = utility(c,σ) + β*dot(Π[:,yi],V[:,ai_next,t+1])\n",
        "            if v>vmax\n",
        "                vmax = v\n",
        "                amax = a_next\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return vmax,amax\n",
        "end"
      ],
      "id": "dc194523",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With this function in hand we can then write a function to iterate over each grid point and calculate $V_{t}$ given $V_{t+1}$:\n"
      ],
      "id": "05531fb3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function iterate_value_function!(p,V,A,t)\n",
        "    for ai in axes(V,2), yi in axes(V,1)\n",
        "        v,a_next = solve_value(ai,yi,V,p,t)\n",
        "        V[yi,ai,t] = v\n",
        "        A[yi,ai,t] = a_next\n",
        "    end\n",
        "end"
      ],
      "id": "cebf26d6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "And finally we can solve the model by doing backward induction from $T$ down to the first period.\n"
      ],
      "id": "763a0f21"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_model(p)\n",
        "    (;T,Π,asset_grid) = p\n",
        "    K_a = length(asset_grid)\n",
        "    K_y = size(Π,1)\n",
        "    V = zeros(K_y,K_a,T+1)\n",
        "    A = zeros(K_y,K_a,T)\n",
        "    for t in reverse(1:T)\n",
        "        iterate_value_function!(p,V,A,t)\n",
        "    end\n",
        "    return (;V,A)\n",
        "end"
      ],
      "id": "e974b2a9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Setting Parameters\n",
        "\n",
        "In theory we can manipulate $\\mu_{t}$ to match observed life-cycle profiles in mean earnings. Next week in recitation we will play around with this. For now, assume that $\\mu$ is constant. The code below sets some parameters `p` for the model.\n"
      ],
      "id": "d97e4951"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "μ = log(10.) #\n",
        "egrid,Π = tauchen(5,0.9,0.1)\n",
        "T = 60\n",
        "income_grid = [μ+egrid[i] for i in 1:5, t in 1:T]\n",
        "p = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0,100,100),\n",
        "    income_grid,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π,\n",
        "    σ = 2.\n",
        ")"
      ],
      "id": "28a107fd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## An example solution\n",
        "\n",
        "Let's solve this model and take a look at the optimal savings policy.\n"
      ],
      "id": "d92bb45d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "model = solve_model(p)\n",
        "(;V,A) = model\n",
        "\n",
        "plot(p.asset_grid,A[1,:,1],label = \"Low shock, period 1\")\n",
        "plot!(p.asset_grid,A[5,:,1],label = \"High shock, period 1\")\n",
        "plot!(p.asset_grid,A[5,:,30],label = \"High shock, period 30\")\n",
        "plot!(p.asset_grid,A[1,:,30],label = \"Low shock, period 30\")\n",
        "plot!(p.asset_grid,A[1,:,55],label = \"Low shock, period 50\")\n",
        "plot!(p.asset_grid,A[5,:,55],label = \"High shock, period 50\")"
      ],
      "id": "cb94fe0b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Can you interpret what is going on here?\n",
        "\n",
        "## Calculating welfare effects\n",
        "\n",
        "Let's assume that everyone starts off with no assets, and then consider the welfare effects of differences in $\\rho$. In particular let's let the persistence of $\\rho$ decline and see what happens.\n"
      ],
      "id": "201356f2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "egrid,Π = tauchen(5,0.45,0.1) #<- move ρ from 0.9 to 0.45\n",
        "income_grid = [μ+egrid[i] for i in 1:5, t in 1:T]\n",
        "p2 = (;p...,income_grid,Π)\n",
        "model2 = solve_model(p2)\n",
        "plot(model.V[:,1,1],label = \"ρ = 0.9\")\n",
        "plot!(model2.V[:,1,1], label = \"ρ = 0.45\")"
      ],
      "id": "4c4a88ca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Spend some time interpreting this! Why does decreasing $\\rho$ have this effect on welfare?\n",
        "\n",
        "## Consumption equivalents\n",
        "\n",
        "The welfare comparisons above are in arbitrary units. How can we convert them to something interpretable? One option is to think about a *consumption equivalent*: the percentage increase in consumption that someone would be willing to take to move from one regime to another. For example, given an initial income level, $y$, the consumption equivalent here would solve:\n",
        "\n",
        "$$ \\mathbb{E}[\\sum_{t=0}^{T}\\beta^{t}u((1+\\omega(y))c_{t}) | y, \\rho = 0.9] = \\mathbb{E}[\\sum_{t=0}^{T}\\beta^{t}u(c_{t}) | y, \\rho = 0.45] $$\n",
        "\n",
        "which solves out to:\n",
        "\n",
        "$$ \\omega(y) = \\left[\\frac{V_{0}(0,y ; \\rho = 0.45)}{V_{0}(0,y ; \\rho = 0.9)}\\right]^{1/(1-\\sigma)} - 1 $$\n",
        "\n",
        "Let's calculate and plot this for each income level:\n"
      ],
      "id": "820bc1da"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "(;σ,β) = p\n",
        "cev = (model2.V[:,1,1] ./ model.V[:,1,1]) .^ (1/(1 - σ)) .- 1\n",
        "plot(cev)"
      ],
      "id": "dc60589c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Which tells us that when we move from $\\rho=0.9$ to $\\rho=0.45$, individuals who begin at the lowest level of $\\varepsilon$ would enjoy a welfare gain that is equivalent to a 33\\% increase in consumption in every period. That's a lot!\n",
        "\n",
        "## Additional Exercise\n",
        "\n",
        "Assume that the initial draw of $\\varepsilon$ is from the stationary distribution of $\\Pi$. Suppose that we want to calculate the average consumption equivalent (i.e. not conditioning on $y$). How could we calculate this? "
      ],
      "id": "0bdeb840"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}