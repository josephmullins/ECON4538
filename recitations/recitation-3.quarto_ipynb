{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Recitation 3\"\n",
        "bibliography: ../reading_list.bib\n",
        "---"
      ],
      "id": "0a1da0c5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using LinearAlgebra, Plots, Distributions, Random"
      ],
      "id": "2166d564",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Extending the welfare decomposition from class\n",
        "\n",
        "In class we studied a decomposition of the gain in utilitarian welfare from moving from a laissez-faire economy to one with perfect insurance (i.e. where everybody receives the same allocation).\n",
        "\n",
        "Let's now consider a decomposition of the welfare differences between two general policy regimes, where neither necessarily provides perfect insurance. First, some definitions...\n",
        "\n",
        "## Setup and definitions\n",
        "\n",
        "Let there be a unit measure of agents in the economy, indexed by $i\\in[0,1]$. As before, assume that agents rank probabilistic sequences of consumption according to:\n",
        "\n",
        "$$ V^{r}_{i} = \\mathbb{E}\\left[\\sum_{t=0}^{T-1}\\beta^{t}u(c^{r}_{i,t})\\right]$$\n",
        "\n",
        "where $\\{c^{r}_{i,t}\\}_{t=0}^{T-1}$ is the sequence of consumption that agent $i$ enjoys under regime $r\\in\\{A,B\\}$.\n",
        "\n",
        "Let $\\bar{c}^{r}_{i}$ be the *certainty equivalent* that solves:\n",
        "$$ \\sum_{t=0}^{T-1}\\beta^{t}u(\\bar{c}^{r}_{i}) = V^{r}_{i}$$\n",
        "for $r\\in\\{A,B\\}$. We know that:\n",
        "$$\\sum_{t=0}^{T-1}\\beta^{t}u(\\bar{c}^{r}_{i}) = \\frac{(1-\\beta^{T})}{1-\\beta}u(\\bar{c}^{r}_{i}) = \\mathcal{V}(\\bar{c}^{r}_{i})$$\n",
        "Finally, define $C=\\int y_{i,t}di = \\int c_{i,t}di$ as aggregate or average consumption in the economy. In both regimes we assume that the resource constraint always holds and there is no aggregate uncertainty. Just as in our lecture, we can define the aggregate certainty equivalent as:\n",
        "$$ \\bar{C}^{r} = \\int \\bar{c}^{r}_{i}di.$$\n",
        "\n",
        "Note that by definition, we have:\n",
        "$$ W^{r} = \\int V^{r}_{i}di = \\int \\mathcal{V}(\\bar{c}^{r}_{i})di $$\n",
        "\n",
        "## The decomposition\n",
        "\n",
        "Note that now we can write:\n",
        "\n",
        "$$ W^{r} = \\mathcal{V}(C^{r}) \\times \\frac{\\mathcal{V}(\\bar{C}^{r})}{\\mathcal{V}(C^{r})} \\times \\frac{\\int \\mathcal{V}(\\bar{c}^{r}_{i})di}{\\mathcal{V}(\\bar{C}^{r})}$$\n",
        "The first term here is the value obtained if we implemented perfect insurance (everyone gets the same consumption in all periods). The second term is the discount on this perfect insurance when everyone is given the average certainty equivalent, and the third term is the further discount coming from inequality in the allocations of certainty equivalents. You can think of the second and third terms as being \"costs\" relative to a benchmark. The second term is the cost of imperfect insurance in the model relative to a \"perfect insurance\" benchmark. The third term is the cost of inequality, stemming from differences in individual certainty equivalent values. Welfare is therefore the product of an aggregate component, an insurance component, and a redistribution component.\n",
        "\n",
        "Since aggregate income and consumption are unchanged by the policies we consider, the first term cancels out when we decompose the welfare changes when moving from regime $A$ to regime $B$ as:\n",
        "\n",
        "$$ \\frac{W^{B}}{W^{A}} = \\frac{\\frac{\\mathcal{V}(\\bar{C}^{B})}{\\mathcal{V}(C^{B})}}{\\frac{\\mathcal{V}(\\bar{C}^{A})}{\\mathcal{V}(C^{A})}} \\times \\frac{\\frac{\\int \\mathcal{V}(\\bar{c}^{A}_{i})di}{\\mathcal{V}(\\bar{C}^{A})}}{\\frac{\\int \\mathcal{V}(\\bar{c}^{A}_{i})di}{\\mathcal{V}(\\bar{C}^{A})}}  $$\n",
        "\n",
        "We can convert these terms into consumption equivalent measures using the formula from [recitation 2](../recitations/recitation-2.qmd):\n",
        "$$\n",
        "\\begin{eqnarray}\n",
        "1 + \\omega = \\left[\\frac{W^{B}}{W^{A}}\\right]^{1/(1-\\sigma)} \\\\\n",
        "1+\\gamma = \\left[\\frac{\\frac{\\mathcal{V}(\\bar{C}^{B})}{\\mathcal{V}(C^{B})}}{\\frac{\\mathcal{V}(\\bar{C}^{A})}{\\mathcal{V}(C^{A})}}\\right]^{1/(1-\\sigma)} \\\\\n",
        "1 + \\alpha = \\left[\\frac{\\frac{\\int \\mathcal{V}(\\bar{c}^{A}_{i})di}{\\mathcal{V}(\\bar{C}^{A})}}{\\frac{\\int \\mathcal{V}(\\bar{c}^{A}_{i})di}{\\mathcal{V}(\\bar{C}^{A})}}\\right]^{1/(1-\\sigma)}\n",
        "\\end{eqnarray}\n",
        "$$\n",
        "with $1+\\omega = (1+\\gamma)(1+\\alpha)$ being the *final* decomposition.\n",
        "\n",
        "The $\\gamma$ term here is the welfare effect of changes in insurance, the $\\alpha$ term represents changes in the equality (or inequality) of the distribution of certainty equivalents.\n",
        "\n",
        "# Adding taxes and transfers to the model\n",
        "\n",
        "In recitation 2 we wrote down code to solve the life-cycle savings model. Below we'll show how to extend the code to allow for a generic system of taxes and transfers.\n"
      ],
      "id": "3b6816bd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# utility\n",
        "utility(c,σ) = c^(1 - σ) / (1 - σ)\n",
        "\n",
        "# tauchen method\n",
        "function tauchen(N, ρ, σ)\n",
        "    # Unconditional standard deviation of the process\n",
        "    σ_y = σ / sqrt(1 - ρ^2)\n",
        "\n",
        "    # Create the grid\n",
        "    y_max = 3. * σ_y\n",
        "    y_min = - 3. * σ_y\n",
        "    grid = range(y_min, y_max, length=N)\n",
        "\n",
        "    # Step size\n",
        "    step = (y_max - y_min) / (N - 1)\n",
        "\n",
        "    # Initialize transition matrix\n",
        "    Π = zeros(N, N)\n",
        "\n",
        "    # Standard normal distribution\n",
        "    d = Normal(0, 1)\n",
        "\n",
        "    # Fill in the transition matrix\n",
        "    for i in 1:N\n",
        "        for j in 1:N\n",
        "            if j == 1\n",
        "                # Probability of transitioning to the lowest state\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ)\n",
        "            elseif j == N\n",
        "                # Probability of transitioning to the highest state\n",
        "                Π[j, i] = 1 - cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            else\n",
        "                # Probability of transitioning to intermediate states\n",
        "                Π[j, i] = cdf(d, (grid[j] - ρ * grid[i] + step/2) / σ) -\n",
        "                         cdf(d, (grid[j] - ρ * grid[i] - step/2) / σ)\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return collect(grid), Π\n",
        "end\n",
        "\n",
        "# iterate the value function\n",
        "function iterate_value_function!(p,V,A,t)\n",
        "    for ai in axes(V,2), yi in axes(V,1)\n",
        "        v,a_next = solve_value(ai,yi,V,p,t)\n",
        "        V[yi,ai,t] = v\n",
        "        A[yi,ai,t] = a_next\n",
        "    end\n",
        "end\n",
        "\n",
        "# solve the model\n",
        "function solve_model(p)\n",
        "    (;T,Π,asset_grid) = p\n",
        "    K_a = length(asset_grid)\n",
        "    K_y = size(Π,1)\n",
        "    V = zeros(K_y,K_a,T+1)\n",
        "    A = zeros(K_y,K_a,T)\n",
        "    for t in reverse(1:T)\n",
        "        iterate_value_function!(p,V,A,t)\n",
        "    end\n",
        "    return (;V,A)\n",
        "end"
      ],
      "id": "d12b138c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The block above includes everything except the function `solve_value` which we are going to edit slightly:\n"
      ],
      "id": "264775ed"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_value(ai,yi,V,p,t)\n",
        "    # note here we assume that p contains a *function*\n",
        "    # called net_income\n",
        "    (;σ,β,Π,r,asset_grid,income_grid,net_income) = p\n",
        "    a = asset_grid[ai]\n",
        "    y = exp(income_grid[yi,t])\n",
        "    y_net = net_income(y)\n",
        "    vmax = -Inf\n",
        "    amax = 0\n",
        "    for ai_next in eachindex(asset_grid)\n",
        "        a_next = asset_grid[ai_next]\n",
        "        # now we include net income in the budget constraint\n",
        "        # instead of just income\n",
        "        c = y_net + a - a_next/(1+r)\n",
        "        if c>0\n",
        "            @views v = utility(c,σ) + β*dot(Π[:,yi],V[:,ai_next,t+1])\n",
        "            if v>vmax\n",
        "                vmax = v\n",
        "                amax = a_next\n",
        "            end\n",
        "        end\n",
        "    end\n",
        "    return vmax,amax\n",
        "end"
      ],
      "id": "05d61f87",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now let's consider a couple of different versions of the net income function."
      ],
      "id": "3dbb4f60"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "no_tax(x) = x\n",
        "\n",
        "progressive_tax(x,λ,τ) = λ * x^(1-τ)"
      ],
      "id": "cccb25bb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "μ = log(10.) #\n",
        "egrid,Π = tauchen(5,0.9,0.1)\n",
        "T = 60\n",
        "income_grid = [μ+egrid[i] for i in 1:5, t in 1:T]\n",
        "p = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0,100,100),\n",
        "    income_grid,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π,\n",
        "    σ = 2.,\n",
        "    net_income = no_tax\n",
        ")"
      ],
      "id": "a9e64088",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "How could we insure that the progressive tax is self financing (i.e. obeys the resource constraint)?  For a given value of $\\tau$, we can pick $\\lambda$ to insure that the average allocation is equal to average income.\n",
        "\n",
        "The code below solves for the steady state of $\\Pi$ and calculates the $\\lambda$ that obeys the resource constraint given $\\tau$. Note that this code works under two assumptions:\n",
        "\n",
        "1. $\\mu_{t}$ is constant over time $t$; and\n",
        "2. The initial draw of $y$ is taken from the stationary distribution of $\\Pi$, $\\pi^*$.\n"
      ],
      "id": "bc64e0cb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function solve_steady_state(Π)\n",
        "    K = size(Π,2)\n",
        "    vals,e = eigen(Π)\n",
        "    return e[:,K] ./ sum(e[:,K])\n",
        "end\n",
        "\n",
        "function solve_lambda(τ,ygrid,pi_star)\n",
        "    return dot(pi_star,ygrid) / dot(pi_star,ygrid.^(1-τ))\n",
        "end\n",
        "\n",
        "# choose progressivity\n",
        "τ = 0.2\n",
        "# solve for the stationary distribution\n",
        "pi_star = solve_steady_state(p.Π)\n",
        "# solve for λ\n",
        "λ = solve_lambda(τ,exp.(income_grid[:,1]),pi_star)"
      ],
      "id": "616b5dc6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we can try solving the model and comparing values with and without this tax system.\n"
      ],
      "id": "355e07dc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "p_new = (;p...,\n",
        "    net_income = x->progressive_tax(x,λ,τ))\n",
        "\n",
        "model0 = solve_model(p)\n",
        "model1 = solve_model(p_new)"
      ],
      "id": "7fce2b9e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plot(model0.V[:,1,1],label=\"no taxes\")\n",
        "plot!(model1.V[:,1,1],label = \"progressive taxes\")"
      ],
      "id": "6396a2a4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Welfare decompositions in the model\n",
        "\n",
        "To decompose the average welfare gain into components, let's first calculate the terms we need:\n"
      ],
      "id": "a8622759"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "(;σ,β) = p\n",
        "C = dot(pi_star,exp.(p.income_grid[:,1]))\n",
        "cbar0 = ((1-σ)*(1-β)/(1-β^T) * model0.V[:,1,1]).^(1/(1-σ))\n",
        "cbar1 = ((1-σ)*(1-β)/(1-β^T) * model1.V[:,1,1]).^(1/(1-σ))\n",
        "Cbar0 = dot(pi_star,cbar0)\n",
        "Cbar1 = dot(pi_star,cbar1)\n",
        "W0 = dot(pi_star,model0.V[:,1,1])\n",
        "W1 = dot(pi_star,model1.V[:,1,1])\n",
        "\n",
        "V_cert(x) = (1-β^T)/(1-β) * utility(x,σ)"
      ],
      "id": "9d729877",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "And with these in hand we can calculate the decomposition:"
      ],
      "id": "470b7ef4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ω = (W1/W0)^(1/(1-σ)) - 1\n",
        "γ = (V_cert(Cbar1) / V_cert(Cbar0))^(1/(1-σ)) - 1\n",
        "α = ((W1 / V_cert(Cbar1)) / (W0 / V_cert(Cbar0)))^(1/(1-σ)) - 1\n",
        "\n",
        "display([1+ω 1+γ 1+α])"
      ],
      "id": "5439dda9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Introducing progressive taxation is equivalent to raising consumption by 2.5\\% in all periods and states of the world. A decent component (1.8\\%) is due to improved insurance against income shocks.\n",
        "\n",
        "To conclude, let's re-calculate this decomposition for a more persistent value of $\\rho$ and interpret the results.\n"
      ],
      "id": "bf7d3ca2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "egrid,Π = tauchen(5,0.99,0.1)\n",
        "income_grid = [μ+egrid[i] for i in 1:5, t in 1:T]\n",
        "p = (;\n",
        "    T,\n",
        "    asset_grid = LinRange(0,100,100),\n",
        "    income_grid,\n",
        "    β = 0.96,\n",
        "    r = 0.04,\n",
        "    Π,\n",
        "    σ = 2.,\n",
        "    net_income = no_tax\n",
        ")\n",
        "\n",
        "# solve for the stationary distribution\n",
        "pi_star = solve_steady_state(p.Π)\n",
        "# solve for λ\n",
        "λ = solve_lambda(τ,exp.(income_grid[:,1]),pi_star)\n",
        "\n",
        "p_new = (;p...,\n",
        "    net_income = x->progressive_tax(x,λ,τ))\n",
        "\n",
        "model0 = solve_model(p)\n",
        "model1 = solve_model(p_new)\n",
        "\n",
        "C = dot(pi_star,exp.(p.income_grid[:,1]))\n",
        "cbar0 = ((1-σ)*(1-β)/(1-β^T) * model0.V[:,1,1]).^(1/(1-σ))\n",
        "cbar1 = ((1-σ)*(1-β)/(1-β^T) * model1.V[:,1,1]).^(1/(1-σ))\n",
        "Cbar0 = dot(pi_star,cbar0)\n",
        "Cbar1 = dot(pi_star,cbar1)\n",
        "W0 = dot(pi_star,model0.V[:,1,1])\n",
        "W1 = dot(pi_star,model1.V[:,1,1])\n",
        "\n",
        "V_cert(x) = (1-β^T)/(1-β) * utility(x,σ)\n",
        "\n",
        "ω = (W1/W0)^(1/(1-σ)) - 1\n",
        "γ = (V_cert(Cbar1) / V_cert(Cbar0))^(1/(1-σ)) - 1\n",
        "α = ((W1 / V_cert(Cbar1)) / (W0 / V_cert(Cbar0)))^(1/(1-σ)) - 1\n",
        "\n",
        "display([1+ω 1+γ 1+α])"
      ],
      "id": "dbdc56c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice that there are quite large welfare gains, but they are entirely coming from redistribution and not from insurance. When we look at the transition matrix $\\Pi$, we see that to numerical precision, the income shocks are essentially permanent:\n"
      ],
      "id": "d9afbb89"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Π"
      ],
      "id": "eb2db105",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "which explains why the welfare gains derive purely from redistribution."
      ],
      "id": "51172e87"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/Users/mullinsj/Library/Jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}